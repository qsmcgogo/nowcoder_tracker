# 课程比赛功能开发文档

## 一、需求概述

在Tracker题库中新增"课程比赛"类型，展示牛客竞赛课程对应的比赛题目。课程比赛的元信息（比赛ID、名称、开始时间等）从数据库动态获取，题目信息也从数据库动态获取。

**前端展示需求**：前端需要按课程分类展示，如"语法入门"、"算法入门"、"数据结构"等。后端已支持按知识点分类查询，前端可以直接调用接口获取特定分类的比赛。

## 二、实现方案

### 2.1 设计思路

1. **后端数据存储**：课程比赛通过`category_id=23`从数据库查询，知识点分类映射写死在Java代码中
2. **后端题目获取**：通过contestId从数据库查询题目列表（复用现有的`acmContestProblemService.getListByContestIds`方法）
3. **类型标识**：使用`subContestType = 23`标识课程比赛类型（对应`ACMCategoryTypeEnum.COURSE`）
4. **知识点分类**：后端支持按知识点分类查询，知识点到contestId的映射写死在代码中
5. **前端查询方式**：前端可以通过`category`参数查询特定知识点的比赛，也可以查询所有课程比赛

### 2.2 知识点分类

后端已实现的知识点分类（共8个分类）：

| 知识点 | 比赛数量 | 说明 |
|--------|---------|------|
| 博弈 | 2 | 组合游戏、对抗搜索、Nim游戏等 |
| 图论 | 6 | 图论相关专题 |
| 字符串 | 7 | 字符串处理相关专题 |
| 数学 | 15 | 数论、组合数学、概率等 |
| 数据结构 | 11 | 树状数组、线段树、平衡树等 |
| 算法入门 | 12 | 模拟、枚举、贪心、递归、分治等 |
| 计算几何 | 8 | 二维基础、凸包、半平面交等 |
| 语法入门 | 7 | C++语法基础 |

**注意**：知识点分类映射已写死在后端代码中（`QuestionTrackerBiz.COURSE_CATEGORY_CONTEST_MAP`），前端无需维护映射关系。

## 三、API接口文档

### 3.1 查询课程比赛列表

**接口地址**：`GET /problem/tracker/list`

**请求参数**：

| 参数名 | 类型 | 必填 | 默认值 | 说明 |
|--------|------|------|--------|------|
| contestType | int | 否 | 0 | 比赛类型，查询课程比赛时传 `23` |
| category | string | 否 | - | 知识点分类，可选值见下方 |
| page | int | 否 | 1 | 页码，从1开始 |
| limit | int | 否 | 100 | 每页数量，最大100 |

**知识点分类可选值**：
- `博弈`
- `图论`
- `字符串`
- `数学`
- `数据结构`
- `算法入门`
- `计算几何`
- `语法入门`

**请求示例**：

```javascript
// 查询所有课程比赛
GET /problem/tracker/list?contestType=23&page=1&limit=20

// 查询"数据结构"分类的比赛
GET /problem/tracker/list?contestType=23&category=数据结构&page=1&limit=20

// 查询"算法入门"分类的比赛
GET /problem/tracker/list?contestType=23&category=算法入门&page=1&limit=20
```

**响应格式**：

```json
{
  "code": 0,
  "msg": "OK",
  "data": {
    "totalCount": 68,
    "papers": [
      {
        "id": 32183,
        "contestName": "牛客竞赛博弈专题班组合游戏基本概念、对抗搜索、Bash游戏、Nim游戏习题",
        "contestType": 0,
        "subContestType": 23,
        "contestUrl": "https://ac.nowcoder.com/acm/contest/32183",
        "beginTime": 1649251200000,
        "questions": [
          {
            "id": 12345,
            "problemId": 67890,
            "title": "题目名称",
            "questionUrl": "https://www.nowcoder.com/practice/...",
            "difficulty": 1500,
            "submissionCount": 1000,
            "acCount": 500
          }
        ]
      }
    ]
  }
}
```

**响应字段说明**：

- `totalCount`: 符合条件的比赛总数（如果指定了category，则为该分类的比赛数量）
- `papers`: 比赛列表
  - `id`: 比赛ID（contestId）
  - `contestName`: 比赛名称
  - `contestType`: 比赛类型（0=ACM比赛）
  - `subContestType`: 子类型（23=课程比赛）
  - `contestUrl`: 比赛链接
  - `beginTime`: 开始时间（时间戳，毫秒）
  - `questions`: 题目列表
    - `id`: 题目ID
    - `problemId`: 题目编号
    - `title`: 题目名称
    - `questionUrl`: 题目链接
    - `difficulty`: 难度值
    - `submissionCount`: 提交次数
    - `acCount`: 通过次数

## 四、后端实现说明

### 4.1 知识点分类映射

后端在`QuestionTrackerBiz.java`中定义了知识点到contestId的映射：

```java
private static final Map<String, List<Long>> COURSE_CATEGORY_CONTEST_MAP = new HashMap<>();

static {
    COURSE_CATEGORY_CONTEST_MAP.put("博弈", Arrays.asList(32183L, 34655L));
    COURSE_CATEGORY_CONTEST_MAP.put("图论", Arrays.asList(34649L, 35796L, ...));
    // ... 其他分类
}
```

### 4.2 查询逻辑

1. **查询所有课程比赛**：通过`category_id=23`从数据库查询所有课程比赛
2. **按知识点过滤**：如果指定了`category`参数，根据映射关系过滤出对应知识点的比赛
3. **分页处理**：对过滤后的结果进行分页

### 4.3 数据来源

- **比赛信息**：从`acm_contest_info`表查询（`category_id=23`）
- **题目信息**：从`acm_contest_problem`表查询
- **知识点映射**：写死在代码中（`COURSE_CATEGORY_CONTEST_MAP`）

## 五、前端实现指南

### 5.1 基础查询

**查询所有课程比赛**：

```javascript
// 获取所有课程比赛（第一页，每页20条）
const response = await fetch('/problem/tracker/list?contestType=23&page=1&limit=20');
const data = await response.json();
const allContests = data.data.papers;
const totalCount = data.data.totalCount;
```

### 5.2 按知识点分类查询

**方案A：后端分页查询（推荐）**

前端每次查询特定知识点的比赛，后端返回分页数据：

```javascript
// 查询"数据结构"分类的比赛
async function fetchContestsByCategory(category, page = 1, limit = 20) {
    const response = await fetch(
        `/problem/tracker/list?contestType=23&category=${encodeURIComponent(category)}&page=${page}&limit=${limit}`
    );
    const data = await response.json();
    return {
        contests: data.data.papers,
        totalCount: data.data.totalCount,
        page: page,
        limit: limit
    };
}

// 使用示例
const result = await fetchContestsByCategory('数据结构', 1, 20);
console.log(`数据结构分类共有 ${result.totalCount} 个比赛`);
console.log(`当前页：${result.contests.length} 个比赛`);
```

**方案B：一次性获取所有数据，前端分页**

如果数据量不大（< 100条），可以一次性获取所有课程比赛，前端自己分页：

```javascript
// 一次性获取所有课程比赛
async function fetchAllCourseContests() {
    const response = await fetch('/problem/tracker/list?contestType=23&page=1&limit=100');
    const data = await response.json();
    return data.data.papers;
}

// 按知识点分组
function groupContestsByCategory(contests) {
    const categories = ['博弈', '图论', '字符串', '数学', '数据结构', '算法入门', '计算几何', '语法入门'];
    const grouped = {};
    
    // 先初始化所有分类
    categories.forEach(cat => grouped[cat] = []);
    
    // 遍历所有比赛，根据知识点分类
    // 注意：这里需要前端维护知识点到contestId的映射，或者调用后端接口查询
    // 推荐使用方案A，直接调用后端接口按分类查询
}
```

### 5.3 推荐实现方式

**推荐使用方案A（后端分页查询）**，原因：

1. ✅ **性能更好**：只传输需要的数据，减少网络传输
2. ✅ **扩展性强**：课程比赛数量增加时不影响性能
3. ✅ **实现简单**：前端只需调用接口，无需维护映射关系
4. ✅ **缓存友好**：后端有缓存机制，查询性能好

**实现示例**：

```javascript
// 知识点分类列表
const COURSE_CATEGORIES = [
    '博弈', '图论', '字符串', '数学', 
    '数据结构', '算法入门', '计算几何', '语法入门'
];

// 为每个分类创建独立的查询函数
class CourseContestService {
    async getContestsByCategory(category, page = 1, limit = 20) {
        const url = `/problem/tracker/list?contestType=23&category=${encodeURIComponent(category)}&page=${page}&limit=${limit}`;
        const response = await fetch(url);
        const data = await response.json();
        return {
            contests: data.data.papers || [],
            totalCount: data.data.totalCount || 0,
            page: page,
            limit: limit,
            totalPages: Math.ceil((data.data.totalCount || 0) / limit)
        };
    }
    
    async getAllCategories() {
        return COURSE_CATEGORIES;
    }
}

// 使用示例
const service = new CourseContestService();

// 获取所有分类
const categories = await service.getAllCategories();

// 查询每个分类的比赛
for (const category of categories) {
    const result = await service.getContestsByCategory(category, 1, 20);
    console.log(`${category}: ${result.totalCount} 个比赛`);
    // 渲染该分类的比赛列表
    renderCategoryContests(category, result.contests);
}
```

### 5.4 前端展示建议

1. **分类标签页**：使用标签页（Tabs）展示不同知识点分类
2. **分页组件**：每个分类独立分页
3. **加载状态**：显示加载中状态，提升用户体验
4. **错误处理**：处理接口错误情况，显示友好提示

## 六、注意事项

### 6.1 接口使用注意事项

1. **category参数**：
   - 必须使用中文名称，如`数据结构`、`算法入门`等
   - 如果传入不存在的知识点，会返回空列表（`totalCount=0`）
   - 参数需要URL编码（`encodeURIComponent`）

2. **分页参数**：
   - `page`从1开始
   - `limit`最大值为100，超过100会自动限制为100
   - 如果`page`超出范围，返回空列表

3. **contestType参数**：
   - 查询课程比赛时，必须传`contestType=23`
   - 如果不传`category`参数，返回所有课程比赛
   - 如果传了`category`参数，只返回该分类的比赛

### 6.2 数据说明

1. **数据来源**：比赛信息和题目信息都从数据库动态获取
2. **数据更新**：数据库中的数据变动会自动反映到接口返回结果
3. **知识点映射**：知识点到contestId的映射写死在后端代码中，如需更新需要修改后端代码

### 6.3 性能说明

1. **缓存机制**：后端有6小时缓存，查询性能良好
2. **分页查询**：推荐使用分页查询，避免一次性加载大量数据
3. **网络优化**：按知识点分类查询可以减少数据传输量

## 七、测试要点

### 7.1 接口测试

1. **查询所有课程比赛**：
   ```
   GET /problem/tracker/list?contestType=23&page=1&limit=20
   ```
   验证：返回所有课程比赛，`totalCount`应该等于68

2. **按知识点查询**：
   ```
   GET /problem/tracker/list?contestType=23&category=数据结构&page=1&limit=20
   ```
   验证：只返回数据结构分类的比赛，`totalCount`应该等于11

3. **不存在的知识点**：
   ```
   GET /problem/tracker/list?contestType=23&category=不存在的分类&page=1&limit=20
   ```
   验证：返回空列表，`totalCount=0`

4. **分页测试**：
   ```
   GET /problem/tracker/list?contestType=23&page=2&limit=10
   ```
   验证：返回第2页的数据，每页10条

### 7.2 数据验证

1. **比赛信息完整性**：验证返回的比赛包含所有必要字段
2. **题目信息完整性**：验证每个比赛都包含题目列表
3. **知识点分类准确性**：验证每个分类返回的比赛数量正确
4. **排序正确性**：验证比赛按`beginTime`降序排列

## 八、常见问题

### Q1: 如何获取所有知识点分类列表？

A: 知识点分类列表写死在后端代码中，前端可以直接使用以下列表：
```javascript
const COURSE_CATEGORIES = [
    '博弈', '图论', '字符串', '数学', 
    '数据结构', '算法入门', '计算几何', '语法入门'
];
```

### Q2: 如果某个知识点没有比赛怎么办？

A: 接口会返回空列表（`papers: []`，`totalCount: 0`），前端需要处理这种情况，显示"暂无比赛"等提示。

### Q3: 可以同时查询多个知识点吗？

A: 当前接口不支持同时查询多个知识点。如果需要，可以：
1. 前端分别调用多次接口，然后合并结果
2. 或者修改后端接口支持多个category参数（需要后端开发）

### Q4: 比赛数据会实时更新吗？

A: 比赛信息和题目信息都从数据库动态获取，会实时更新。但后端有6小时缓存，数据更新可能有最多6小时的延迟。

### Q5: 如何判断一个比赛属于哪个知识点？

A: 后端已经维护了知识点到contestId的映射，前端只需要调用接口查询即可，无需自己判断。

## 九、相关代码位置

- **后端主要文件**：
  - `sparta_common/src/main/java/com/wenyibi/futuremail/biz/questionrpc/QuestionTrackerBiz.java`
    - `COURSE_CATEGORY_CONTEST_MAP` - 知识点映射（第135-146行）
    - `getPaperBySubType()` - 查询方法（第223-254行）
    - `countPaperBySubType()` - 统计方法（第260-286行）
  - `sparta_web/src/main/java/com/wenyibi/futuremail/controllers/problem/tracker/TrackerController.java`
    - `getQuestionBySubType()` - 接口方法（第72-83行）

- **数据文件**：
  - `sparta_common/src/main/java/com/wenyibi/futuremail/biz/questionrpc/课程比赛对应一览.txt` - 原始数据文件

