# 烙饼排序问题题解（IDA* 算法）

## 简要题意

给定一个包含 $n$ 个不同整数的序列，目标是通过尽可能少的操作次数将其排序为升序。每次操作可以选择序列的前 $k$ 个元素（$k \in [2, n]$）并将其翻转。

---

## 算法分析

这是一个典型的状态搜索问题，我们可以将每一种排列视为一个状态节点。从一个状态出发，通过一次翻转操作可以转移到另一个状态。问题的目标是在这个巨大的状态图中，寻找从初始状态到目标状态（升序排列）的最短路径。

### 为什么不用 BFS 或普通 DFS？

-   **BFS (广度优先搜索)**：虽然 BFS 能够保证找到最短路径，但它需要存储每一层的所有状态，当 $n$ 稍大时（例如 $n>10$），状态数量会爆炸式增长，导致内存溢出。
-   **DFS (深度优先搜索)**：朴素的 DFS 会盲目地深入搜索，很容易陷入一条很长的无效路径中，无法保证在有限时间内找到最优解，甚至不一定能找到解。

### IDA\* (迭代加深 A\* 搜索)

对于求解最短路径且状态空间巨大的问题，IDA\* 是一个非常高效的算法。它结合了**迭代加深 (Iterative Deepening)** 和 **A\* 算法的估价函数剪枝**。

#### 1. 迭代加深

我们不让 DFS 无限制地搜索，而是给它设定一个最大搜索深度 `dep`。
-   首先，我们从一个较小的 `dep` 开始（例如，从一个合理的下界开始）。
-   然后，我们进行一次完整的深度优先搜索，但任何路径的深度都不能超过 `dep`。
-   如果在该深度限制下没有找到解，我们就将 `dep` 增加 1，然后**从头开始**新一轮的搜索。
-   这个过程不断重复，直到找到解为止。

由于我们是从浅到深地扩大搜索范围，因此**第一个找到的解一定是最优解（即步数最少的解）**。

#### 2. A\* 启发式搜索与剪枝

为了让迭代加深的过程更高效，我们引入 A\* 算法的核心思想：**估价函数 (Heuristic Function)**。

估价函数 $h(state)$ 用于**估计**从当前状态 `state` 到达目标状态**最少**还需要多少步。一个好的估价函数是 IDA\* 算法效率的灵魂。

剪枝的核心思想是：
> 如果 `当前已走步数 + 预估未来最少步数 > 最大深度限制`，那么这条路径显然不可能在深度限制内找到解，我们应该立即放弃（剪枝）。

在本题中，我们使用的估价函数 `check()` 是：
> 计算当前序列中，相邻两个元素 `a[i]` 和 `a[i-1]` 满足 `abs(a[i] - a[i-1]) != 1` 的数量。

这个估价函数是“可接受的”(admissible)，因为它**永远不会高估**实际所需步数。一次翻转操作最多能改变两个位置的相邻关系（翻转段的头和尾），因此 `check()` 的值是未来所需步数的一个非常乐观的下界，这保证了算法的正确性。

---

## 数据预处理：离散化

题目中铁盘的半径可能是任意数值，但我们只关心它们之间的大小关系。因此，我们可以通过**离散化**将这些数值映射到 `1, 2, ..., n`。这极大地简化了我们的估价函数 `check()` 的逻辑，使其可以直接判断 `a[i]` 和 `a[i-1]` 是否相差为1。

---

## 代码实现

```cpp
#include <bits/stdc++.h>

using namespace std;

int a[1010];
int n;
int dep; // IDA* 的核心：当前迭代的深度/成本上限

/**
 * 估价函数 (Heuristic Function)
 * 计算当前序列中，值不连续的相邻元素对的数量。
 * 这是一个乐观的、不会被高估的未来成本估计，是 A* 剪枝的关键。
 */
int check() {
    int cnt = 0;
    for (int i = 2; i <= n + 1; i++) {
        // 为了方便处理边界，我们在 a[n+1] 处设置了一个值为 n+1 的哨兵
        if (abs(a[i] - a[i - 1]) != 1) {
            cnt++;
        }
    }
    return cnt;
}

/**
 * IDA* 的核心搜索函数
 * @param p 上一次翻转的长度，用于剪枝，避免执行无效的撤销操作
 * @param cnt 当前已经走的步数（深度）
 * @return bool 是否在当前深度限制(dep)下找到了解
 */
bool dfs(int p, int cnt) {
    // A* 剪枝：如果 当前步数 + 预估未来最少步数 > 深度上限，则此路不通
    if (check() + cnt > dep) {
        return false;
    }
    // 终止条件：如果估价函数为0，说明序列已经有序，找到了解
    if (check() == 0) {
        return true;
    }

    // 遍历所有可能的下一步操作（翻转前 j 个元素）
    for (int j = 2; j <= n; j++) {
        // 剪枝：如果本次操作是撤销上一步操作，则跳过
        if (j == p) continue;

        // 执行操作
        reverse(a + 1, a + j + 1);
        // 向下递归
        if (dfs(j, cnt + 1)) {
            return true; // 如果下层找到了解，立刻返回 true，终止搜索
        }
        // 撤销操作（回溯），恢复现场
        reverse(a + 1, a + j + 1);
    }

    // 在当前深度限制下，从这个节点出发的所有路径都无法找到解
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    // --- 数据读取与离散化 ---
    map<int, int> mp;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        mp[a[i]] = 0;
    }
    int rank = 1;
    for (auto const& [key, val] : mp) {
        mp[key] = rank++;
    }
    for (int i = 1; i <= n; i++) {
        a[i] = mp[a[i]];
    }

    // 设置哨兵，简化 check() 函数的边界处理
    a[n + 1] = n + 1;

    // --- IDA* 迭代加深循环 ---
    dep = check(); // 深度上限从最乐观的估价值开始
    while (true) {
        // 如果在当前深度限制下找到了解，则循环结束
        if (dfs(0, 0)) {
            break;
        }
        // 否则，增加深度限制，进行新一轮更大范围的搜索
        dep++;
    }

    cout << dep << endl;

    return 0;
}

```

---

## 复杂度分析

-   **时间复杂度**: $O(n \cdot (b_{eff})^d)$
    -   这是一个指数级算法，因为问题本身是 NP-hard 的。
    -   $d$ 是最优解的步数，上界为 $O(n)$。
    -   $b_{eff}$ 是有效分支因子，由于估价函数的强大剪枝，它是一个远小于 $n$ 的常数。
    -   $O(n)$ 的乘积项是每次递归中 `check()` 和 `reverse()` 操作的开销。
-   **空间复杂度**: $O(n)$
    -   主要开销来自于存储序列的数组 `a`、用于离散化的 `map` 以及递归调用的栈深度，均为 $O(n)$ 级别。

